# 自底向上
#1、钢条切割的顺序无关紧要，所以可以使用动态规划
#动态规划思想的本质，就是找到大量重复计算的子问题，将其解记录下来，当再次遇到的时候通过查表得到解，用少量空间节省大量时间。
#2、当该函数计算[公式] = 4 时，分别会计算 [公式] = 3，2，1，0，
# 在计算 [公式] = 3 时，分别会计算 [公式] = 2，1，0；
# 以此推，可见，当 [公式] = 4 的情况全部计算完毕时，[公式] = 0 一共计算了8次，
# [公式] = 1 一共计算了4次，[公式] = 2 一共计算了2次，[公式] = 3 计算了一次。
# 可见，当 [公式] = 5 时，[公式] = 0 一共要计算16次。
# 这就是该算法的问题，自顶向下求解问题时，有太多的子问题，被重复计算了很多遍。
# 然而这些重复计算的数值，如果被储存下来，当再次遇到时，只需要查表获取，可以节省大量的计算时间。
# 如此改进以后，就是如下的动态规划算法。

import matplotlib.pyplot as plt # plt 用于显示图片
import matplotlib.image as mpimg # mpimg 用于读取图片
lena = mpimg.imread('./钢条切割.jpg')
def BottomUpCutRod(p, n):
    r = [0]*(n+1)
    for i in range(1,n+1):
        if i<=0:
            return 0
        q = 0
        for j in range(1,i+1):
            q = max(p[i], r[i-j])
        r[i] = q
    return r

plt.imshow(lena) # 显示图片
plt.axis('off') # 不显示坐标轴
plt.show()
p=[0,1,5,8,9,10,17,17,20,24,30]
print(BottomUpCutRod(p, 10))